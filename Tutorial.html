<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js ayu">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tutorial - Liquidata</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('ayu')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="intro.html">Introduction</a></li><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.</strong> Instalation</a></li><li class="chapter-item expanded "><a href="mPyPl.html"><strong aria-hidden="true">2.</strong> Comparison to mPyPl</a></li><li class="chapter-item expanded "><a href="whirlwind.html"><strong aria-hidden="true">3.</strong> Whirlwind tour of basic features</a></li><li class="chapter-item expanded "><a href="Tutorial.html" class="active"><strong aria-hidden="true">4.</strong> Tutorial</a></li><li class="chapter-item expanded "><a href="Architecture.html"><strong aria-hidden="true">5.</strong> Architecture</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu (default)</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Liquidata</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#tutorial" id="tutorial">Tutorial</a></h1>
<p>In this tutorial we'll gradually build up the code that appears in the
introduction, and explore some other features along the way.</p>
<p>The following code will traverse your entire filesystem, and print information
about every directory and the files in it. Be ready to interrupt it!</p>
<h2><a class="header" href="#a-very-simple-pipe" id="a-very-simple-pipe">A very simple pipe</a></h2>
<pre><code class="language-python">import os
from liquidata import pipe, source, sink

pipe(source &lt;&lt; os.walk('/'), sink(print))
</code></pre>
<ul>
<li>
<p>We created a pipe which uses the iterable <code>os.walk('/')</code> as its source. The
following 3 variations are synonymous:</p>
<ul>
<li><code>source &lt;&lt; iterable</code></li>
<li><code>iterable &gt;&gt; source</code></li>
<li><code>source(iterable)</code></li>
</ul>
</li>
<li>
<p>The items in the source are sent down the pipeline</p>
</li>
<li>
<p>In this case the pipeline is very short, it contains only a single sink. <code>sink</code>:</p>
<ul>
<li>feeds any items it receives into the (presumably side-effecting) function it
contains</li>
<li>stops the items from propagating further downstream</li>
</ul>
</li>
<li>
<p><code>os.walk('/')</code> traverses the entire filesystem: information about <em>each</em>
directory in the filesystem is send down the pipe and printed out. Your screen
is flooded with information.</p>
</li>
</ul>
<p>Let's try to remove the need to interrupt the pipeline manually.</p>
<h2><a class="header" href="#limiting-the-number-of-items" id="limiting-the-number-of-items">Limiting the number of items</a></h2>
<pre><code class="language-python">import os
from liquidata import pipe, source, take, sink

pipe(source &lt;&lt; os.walk('/'), take(3), sink(print))
</code></pre>
<ul>
<li>
<p>We have introduced a new component into the pipe: <code>take(3)</code>. Its purpose is to
limit the number of items flowing through the pipe.</p>
</li>
<li>
<p>Only the first three items coming out of the source are printed to the screen.</p>
</li>
<li>
<p>But the pipeline does not terminate, because the entire source is being pushed
through the pipe. <code>take</code> only limits how many of them get through.</p>
</li>
<li>
<p>If you do not interrupt this, it will eventually terminate after the source is
exhausted (your whole filesystem has been traversed).</p>
</li>
</ul>
<h2><a class="header" href="#push-vs-pull" id="push-vs-pull">Push vs pull</a></h2>
<ul>
<li>
<p><code>liquidata</code> pushes the data through the pipeline using coroutines. A perfectly
valid alternative choice would be to pull the data through the pipe using
generators.</p>
</li>
<li>
<p>Pushing makes it easy to split the stream into separate, independent branches
leading to distinct sinks (or outputs); pulling makes it easier to join
independent sources (or inputs). The former made more sense in the context in
which <code>liquidata</code> was originally needed.</p>
</li>
<li>
<p><code>liquidata</code> will support pulling in the future.</p>
</li>
<li>
<p>If the data were being pulled, the previous example would terminate as soon as
the first 3 items from the source had been processed.</p>
</li>
<li>
<p>In a pull-architecture, <code>take</code> has to send an '<em>I am closed, you won't get any
more data from me</em>' message downstream. Consequently, downstream will stop
asking for more. In a push-architecture, <code>take</code> has two choices:</p>
<ul>
<li>
<p>Keep rejecting all subsequent items it receives, until upstream stops
sending data.</p>
</li>
<li>
<p>Send a '<em>please stop sending data</em>' message upstream. In this case, any
other branches on the network will also immediately stop receiving any data.
This is not always desirable.</p>
</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#early-termination-of-push" id="early-termination-of-push">Early termination of push</a></h2>
<p>We can instruct <code>take</code> to close down the whole network, as soon as it has let
through all the items it needs, by passing in <code>close_all=True</code>:</p>
<pre><code class="language-python">import os
from liquidata import pipe, source, take, sink

pipe(source &lt;&lt; os.walk('/'), take(3, close_all=True), sink(print))
</code></pre>
<ul>
<li>
<p>The first three items are printed to the screen, and the pipeline terminates immediately.</p>
</li>
<li>
<p>All <code>liquidata</code> components with the ability to reject all subsequent items,
should have a <code>close_all</code> option.</p>
</li>
</ul>
<h2><a class="header" href="#synchronized-branches-and-compound-flow" id="synchronized-branches-and-compound-flow">Synchronized branches and compound flow</a></h2>
<p>The items generated by <code>os.walk</code> are 3-tuples, containing:</p>
<ul>
<li>A filesystem path</li>
<li>A list of directories found on that path</li>
<li>A list of files found on that path</li>
</ul>
<p>Let's give these components names within our pipeline</p>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, take, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The new component is <code>name.path.dirs.files</code>.</p>
</li>
<li>
<p>It specifies three names: <code>path</code>, <code>dirs</code> and <code>files</code>.</p>
</li>
<li>
<p>Therefore it expects to receive an iterable containing three items (in this
case, the 3-tuple coming out of <code>os.walk</code>)</p>
</li>
<li>
<p>It creates a namespace containing those three names, bound to the
corresponding items in the tuple.</p>
</li>
<li>
<p>The resulting namespace continues down the pipe.</p>
</li>
<li>
<p>The components of such namespaces can be thought of as parallel, synchronized,
named branches.</p>
</li>
<li>
<p><code>liquidata</code> also supports unsynchronized branches. We'll meet these later.</p>
</li>
<li>
<p><code>name.single_name</code> wraps the <em>whole</em> item it receives in a namespace. By
contrast, <code>name.more.than.one</code> <em>unpacks</em> the item it receives and wraps its
components in a namespace.</p>
</li>
</ul>
<h2><a class="header" href="#picking-components-from-compound-flow" id="picking-components-from-compound-flow">Picking components from compound flow</a></h2>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files,
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The new component is <code>get.files</code>. It</p>
<ul>
<li>expects a compound item (Namespace) from upstream</li>
<li>selects the specified component (<code>files</code>, in this example)</li>
<li>sends it downstream.</li>
</ul>
</li>
<li>
<p>Consequently, this program prints three lists:</p>
<ul>
<li>one for each of the first three directories visited by <code>os.walk('/')</code></li>
<li>each containing the names of the files in that directory</li>
</ul>
</li>
</ul>
<h2><a class="header" href="#join" id="join"><code>join</code></a></h2>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, join, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files,
    take(3, close_all=True),
    join,
    sink(print))
</code></pre>
<ul>
<li>
<p>The new component is <code>join</code>.</p>
</li>
<li>
<p>It expects iterables and sends their items downstream, one by one.</p>
</li>
<li>
<p>Consequently, this program prints the names of the files found in the first 3
directories visited by <code>os.walk('/')</code>.</p>
</li>
<li>
<p>This is exactly the same information as in the previous example, except that,
rather than being grouped in 3 lists, the names appear in one long chain.</p>
</li>
</ul>
<p>Try swapping the <code>take</code> and the <code>join</code> components:</p>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, join, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files,
    join,
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>This time only 3 names are printed</p>
</li>
<li>
<p>Previously, all the names corresponding to the first three directories were
printed.</p>
</li>
<li>
<p><code>join</code> plays a role similar to inner loops.</p>
</li>
<li>
<p><code>flat(fn)</code> is an alternative spelling of <code>fn, join</code></p>
</li>
</ul>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    flat(get.files),
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p><code>flat(get.files)</code> replaced <code>get.files, join</code> from the previous example.</p>
</li>
<li>
<p>The behaviour doesn't change.</p>
</li>
</ul>
<h2><a class="header" href="#filters" id="filters">filters</a></h2>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, join, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files,
    join,
    { lambda x: x.endswith('.py') },
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The new component is <code>{ lambda x: x.endswith('.py') }</code></p>
</li>
<li>
<p>Braces (<code>{ }</code>) create filters, with the contained function being used as the
predicate.</p>
</li>
<li>
<p>In this example, we only let through filenames which end in <code>.py</code>.</p>
</li>
<li>
<p>We close the pipeline after seeing the first three of those.</p>
</li>
</ul>
<h2><a class="header" href="#reducing-lambda-noise-use" id="reducing-lambda-noise-use">reducing <code>lambda</code> noise: <code>use</code></a></h2>
<p>The purpose of <code>lambda</code> in the last example, is to bind the second argument of a
function (in this example, <code>str.endswith(&lt;string&gt;, &lt;ending&gt;)</code>), while leaving
the first argument unbound. This situation arises rather frequently, and
<code>lambda</code> often adds a lot of syntactic noise.</p>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, join, use, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files,
    join,
    { use(str.endswith, '.py') },
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The new component is <code>use(str.endswith, '.py')</code> which replaces <code>lambda x: x.endswith('.py')</code>.</p>
</li>
<li>
<p>The following two lines are synonymous:</p>
<pre><code class="language-python">lambda x: fn(x, A2)
      use(fn,   A2)
</code></pre>
</li>
<li>
<p>More generally:</p>
<pre><code class="language-python">lambda x: fn(x, A2, A3, K1=v1, K2=v2)
      use(fn,   A2, A3, K1=v1, K2=v2)
</code></pre>
</li>
<li>
<p>In other words:</p>
<pre><code class="language-python">lambda x: fn(x, *args, **kwds)
      use(fn,   *args, **kwds)
</code></pre>
</li>
</ul>
<h2><a class="header" href="#key-filters" id="key-filters">key-filters</a></h2>
<p>Imagine we were interested in filenames whose length is greater than 5.</p>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, join, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files,
    join,
    { lambda x: x &lt; 5 : len },
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The new component is <code>{ lambda x: x &lt; 5 : len }</code>.</p>
</li>
<li>
<p>The important new feature within that component is <code>: len</code>.</p>
</li>
<li>
<p>We have already seen the use of braces (<code>{ predicate }</code>) as filters.</p>
</li>
<li>
<p>This is a key-filter: <code>{ predicate : key }</code>.</p>
</li>
<li>
<p>The predicate does not look at the item itself, but at <code>key(item)</code>.</p>
</li>
<li>
<p>If the predicate is satisfied, the item itself (rather than <code>key(item)</code>)
continues downstream.</p>
</li>
</ul>
<h2><a class="header" href="#reducing-lambda-noise-arg" id="reducing-lambda-noise-arg">reducing <code>lambda</code> noise: <code>arg</code></a></h2>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, join, arg, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files,
    join,
    { arg &lt; 5 : len },
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The new component is <code>arg &lt; 5</code> which replaces <code>lambda x: x &lt; 5</code></p>
</li>
<li>
<p><code>arg</code> is a means of creating anonymous functions by binding one operand of an
operator. It works for most Python operators.</p>
</li>
<li>
<p><code>from liquidata import arg as _</code> might be tempting ... but is it wise?</p>
</li>
</ul>
<h2><a class="header" href="#adding-new-synchronized-branches-put" id="adding-new-synchronized-branches-put">Adding new synchronized branches: <code>put</code></a></h2>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, put, get, take, join, arg, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    (lambda ns: len(ns.files)) &gt;&gt; put.Nfiles,
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The new component is <code>(lambda ns: len(ns.files)) &gt;&gt; put.Nfiles</code></p>
<ul>
<li>
<p><code>lambda ns: len(ns.files)</code> accepts a namespace, and returns the length of
one of the values in the namespace.</p>
</li>
<li>
<p><code>&gt;&gt; put.Nfiles</code> adds the returned value as a new entry in the namespace,
under the name <code>Nfiles</code>.</p>
</li>
</ul>
</li>
<li>
<p>Before this point, there were three synchronized branches in the stream (<code>path</code>, <code>dirs</code>, <code>files</code>). After
this point there are four (the aforementioned three, and <code>Nfiles</code>).</p>
</li>
</ul>
<h2><a class="header" href="#get-" id="get-"><code>get *</code></a></h2>
<p>The last example can be written more conveniently with <code>get *</code></p>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, put, take, join, arg, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files * len &gt;&gt; put.Nfiles,
    take(3, close_all=True),
    sink(print))
</code></pre>
<p><code>get.files * len</code> replaced <code>(lambda ns: len(ns.files))</code></p>
<p>The following three variants are synonymous</p>
<pre><code class="language-python">(lambda ns: len(   ns.files)) &gt;&gt; put.Nfiles
            len * get.files   &gt;&gt; put.Nfiles
get.files * len               &gt;&gt; put.Nfiles
</code></pre>
<ul>
<li>
<p><code>get</code> without the <code>*</code> is essentially a shorthand for <code>operator.attrgetter</code>:</p>
<pre><code class="language-python">attrgetter('a')
get        .a
</code></pre>
<p>are synonymous, as are</p>
<pre><code class="language-python">attrgetter('a', 'b', 'c')
get        .a   .b   .c
</code></pre>
</li>
<li>
<p><code>get</code> can also play the role of <code>operator.itemgetter</code>:</p>
<pre><code class="language-python">itemgetter(key_or_index)
get       [key_or_index]
</code></pre>
<p>are synonymous.</p>
<p>Unfortunately, Python's <code>__getitem__</code> syntax throws a spanner in the works,
because it cannot distinguish between</p>
<pre><code class="language-python">obj[ a, b ]
obj[(a, b)]
</code></pre>
<p>so</p>
<pre><code class="language-python">       get[ a,b ]
itemgetter( a,b ) # would like this
itemgetter((a,b)) # but get this
</code></pre>
</li>
<li>
<p>When combined with <code>*</code>, <code>get</code> not only extracts values from a compound object,
but also <em>unpacks</em> them into a function call, much like the <code>*</code> in Python's
standard <code>fn(*args)</code> syntax.</p>
<p>It is worth noting the following similarities and differences between <code>get ... ,</code> and <code>get ... *</code>:</p>
<pre><code class="language-python">get.a , fn  # fn(ns.a)
get.a * fn  # same as above
</code></pre>
<pre><code class="language-python">get.a.b , fn  # fn((ns.a, ns.b))
get.a.b * fn  # fn( ns.a, ns.b )
</code></pre>
<p>The comma does <em>not</em> unpack the tuple: the whole tuple is passed as a <em>single</em>
argument to <code>fn</code>. In contrast, the star unpacks the tuple and <code>fn</code> receives
its contents as separate arguments.</p>
</li>
<li>
<p><code>get *</code> also has an important interaction with <code>put</code>. Consider</p>
<pre><code class="language-python">get.a * fn &gt;&gt; put.b  # ns.b = (fn(ns.a))
get.a , fn &gt;&gt; put.b  # Error!
</code></pre>
<p>The first case is parsed as <code>(get.a * fn) &gt;&gt; put.b</code>. Consequently <code>put</code>
attempts to inject <code>b</code> into the item received by <code>(get.a * fn)</code>: that item
must be a namespace, if <code>get.a</code> is to work. The <code>b</code> will be placed in that
namespace.</p>
<p>The second case is parsed as <code>get.a, (fn &gt;&gt; put.b)</code>. Consequently <code>put</code>
attempts to inject <code>b</code> into the item received by <code>fn</code>, which has already been
unpacked by <code>get.a</code>, and will therefore NOT be a namespace.</p>
</li>
</ul>
<p>Armed with this knowledge, let's return to the code we were developing.</p>
<h2><a class="header" href="#putting-get--and--put-to-work" id="putting-get--and--put-to-work">Putting <code>get *</code> and <code>&gt;&gt; put</code> to work</a></h2>
<p>Recall that:</p>
<ul>
<li>
<p>We have a compound flow containing three synchronized branches: <code>path</code>, <code>dirs</code>
and <code>files</code>.</p>
</li>
<li>
<p>Alternatively we can say that the items flowing through the pipe are
namespaces, each containing the names <code>path</code>, <code>dirs</code> and <code>files</code>.</p>
</li>
<li>
<p><code>path</code> is a single value; <code>files</code> is a list.</p>
</li>
<li>
<p>We have managed to create a stream of (unqualified) filenames which end in
<code>.py</code>.</p>
</li>
</ul>
<p>The code looked like this:</p>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, take, join, use, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files,
    join,
    { use(str.endswith, '.py') },
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>We would like to look at the contents of the <code>.py</code> files.</p>
</li>
<li>
<p>In order to open the files, we will need to know their fully qualified names.</p>
</li>
<li>
<p><code>os.path.join(path, filename)</code> can create these for us, as long as we can feed
it a path and a filename.</p>
</li>
<li>
<p>Before <code>get.files</code> the stream contained the <code>path</code> we need, but the filename
was not obviously accessible. After <code>get.files, join</code>, the stream contains
only filenames: <code>path</code> is no longer available.</p>
</li>
<li>
<p>The solution is to <em>add</em> the filenames to the compound stream, rather than
replacing it. This can be done with <code>put</code>.</p>
</li>
</ul>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, put, take, join, use, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename,
    get.path.filename,
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The first change to the code is</p>
<pre><code class="language-python">get.files ,  join, { use(str.endswith, '.py') }                    # old
get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename   # new
</code></pre>
<p>The old version:</p>
<ul>
<li>picks <code>files</code> out of the namespace</li>
<li>throws away the namespace</li>
<li>turns a stream of lists of filenames into a stream of individual filenames</li>
<li>discards non-<code>.py</code> filenames</li>
</ul>
<p>The new version:</p>
<ul>
<li>feeds <code>files</code> into a sub-pipe</li>
<li>the sub-pipe:
<ul>
<li>turns a stream of lists of filenames into a stream of individual filenames</li>
<li>discards non-<code>.py</code> filenames</li>
</ul>
</li>
<li>for <em>each</em> <code>.py</code> file coming out of the sub-pipe:
<ul>
<li>adds the filename to the namespace</li>
<li>sends the augmented namespace downstream</li>
</ul>
</li>
</ul>
</li>
<li>
<p>The second change is the addition of <code>get.path.filename</code>, which extracts the
two values that interest us from the namespace.</p>
</li>
</ul>
<p>Consequently, the code prints out the first three <code>.py</code> filenames, in a tuple
together with the paths to the directories that contain them.</p>
<p>We can use <code>*</code> to unpack these tuples into separate arguments when calling <code>os.path.join</code>:</p>
<pre><code class="language-python">import os
from liquidata import pipe, source, name, get, put, take, join, use, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename,
    get.path.filename * os.path.join,
    take(3, close_all=True),
    sink(print))
</code></pre>
<ul>
<li>
<p>The new addition is <code> * os.path.join</code></p>
</li>
<li>
<p>The code now prints the fully qualified names of the first three <code>.py</code> files.</p>
</li>
</ul>
<h2><a class="header" href="#analysing-the-file-contents" id="analysing-the-file-contents">Analysing the file contents</a></h2>
<pre><code class="language-python">import os
from keyword import iskeyword
from liquidata import pipe, source, name, get, put, take, join, use, sink

pipe(
    source &lt;&lt; os.walk('/'),
    name.path.dirs.files,
    get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename,
    get.path.filename * os.path.join,
    open,
    join,
    use(str.split, '#', maxsplit=1),
    get[0],
    str.split,
    join,
    { iskeyword },
    take(30, close_all=True),
    sink(print))
</code></pre>
<p>There are quite a few new additions, but they should all be familiar by now:</p>
<ul>
<li>
<p><code>open</code> (a Python builtin) turns each filename into an iterator over the lines
in the file.</p>
</li>
<li>
<p><code>join</code> turns the stream of file iterators into a continuous stream of lines in
<em>all</em> the files.</p>
</li>
<li>
<p><code>use(str.split, '#', maxsplit=1)</code> splits each line into <code>[&lt;code&gt;, &lt;comment&gt;]</code>
pairs.</p>
</li>
<li>
<p><code>get[0]</code> picks the code, and throws away the comment.</p>
</li>
<li>
<p><code>str.split</code> turns the code on any line into a sequence of tokens. [This
tokenizer is much too naive for real uses, but it will do for the purposes of
our example.]</p>
</li>
<li>
<p><code>join</code> gives a continuous stream of tokens on all lines in all files.</p>
</li>
<li>
<p><code>{ iskeyword }</code> filters out non-keywords.</p>
</li>
<li>
<p>Changing <code>take</code>'s first argument from <code>3</code> to <code>30</code> allows us to see a bit more
output.</p>
</li>
</ul>
<h2><a class="header" href="#reusable-pipes" id="reusable-pipes">Reusable pipes</a></h2>
<p>Our pipe starts with <code>source &lt;&lt; ...</code>. This means that data are pushed through
the pipe as soon as it is defined. It is possible to define a pipe for reuse,
decoupling it from the data that will flow through it.</p>
<pre><code class="language-python">import os
from keyword import iskeyword
from liquidata import pipe, source, name, get, put, take, join, use, sink

fn = pipe(
    name.path.dirs.files,
    get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename,
    get.path.filename * os.path.join,
    open,
    join,
    use(str.split, '#', maxsplit=1),
    get[0],
    str.split,
    join,
    { iskeyword },
    take(30, close_all=True),
    sink(print))

fn(os.walk('/'))
</code></pre>
<ul>
<li>
<p><code>source</code> has been removed from the pipe</p>
</li>
<li>
<p><code>pipe</code> now returns a function</p>
</li>
<li>
<p>That function accepts an iterable argument, and pushes it through the pipe.</p>
</li>
<li>
<p>The function can be called multiple times, with different inputs.</p>
</li>
</ul>
<h2><a class="header" href="#pipe-functions" id="pipe-functions">Pipe functions</a></h2>
<p>TODO pipe(...)</p>
<h2><a class="header" href="#composable-pipes" id="composable-pipes">Composable pipes</a></h2>
<p>Pipes are pipe components themselves:</p>
<pre><code class="language-python">import os
from keyword import iskeyword
from liquidata import pipe, source, name, get, put, take, join, use, sink

hard_work = (
    name.path.dirs.files,
    get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename,
    get.path.filename * os.path.join,
    open,
    join,
    use(str.split, '#', maxsplit=1),
    get[0],
    str.split,
    join,
    { iskeyword })

fn = pipe(hard_work, take(5, close_all=True), sink(print))
fn(os.walk('/'))

pipe(source &lt;&lt; os.walk('/'), hard_work, take(8, close_all=True), sink(print))
</code></pre>
<ul>
<li>
<p>The bulk of our pipe was extracted into a tuple called <code>hard_work</code>.</p>
</li>
<li>
<p><code>hard_work</code> was used as a component in different pipes</p>
</li>
</ul>
<h2><a class="header" href="#side-effects-vs-results" id="side-effects-vs-results">Side-effects vs. results</a></h2>
<p>So far, we have been printing out the values that reach the end of the pipe with <code>sink(print)</code>.</p>
<ul>
<li>
<p><code>sink</code> stops items from proceeding downstream. So it makes no sense for <code>sink</code>
to appear anywhere other than the end of a pipe.</p>
</li>
<li>
<p><code>sink</code> passes all items that reach it from upstream, to the function it
contains (<code>print</code> in all our examples so far). The idea is that the function
should perform some side-effect with the values it receives.</p>
</li>
</ul>
<p>Let's try removing the sink:</p>
<pre><code class="language-python">pipe(source &lt;&lt; os.walk('/'), hard_work, take(8, close_all=True))
</code></pre>
<p>Any items reaching the end of the pipe, are collected into a list, which is
returned as the result of the pipe.</p>
<h2><a class="header" href="#different-strategies-for-collecting-results" id="different-strategies-for-collecting-results">Different strategies for collecting results</a></h2>
<pre><code class="language-python">from operator import add

pipe(source &lt;&lt; range(10), out(min))        #    0
pipe(source &lt;&lt; range(10), out(max))        #    9
pipe(source &lt;&lt; range(10), out(add))        #   45
pipe(source &lt;&lt; range(10), out(add, 1000))  # 1045
</code></pre>
<ul>
<li>
<p>The default behaviour of collecting all items that reach the end of the pipe
into a list, can be overridden with <code>out</code>.</p>
</li>
<li>
<p><code>out</code> accepts a binary function, which will be used to <em>fold</em> or <em>reduce</em> the
items into a single value.</p>
</li>
<li>
<p><code>out</code> accepts an optional default or initial value, just like
<code>functools.reduce</code>.</p>
</li>
</ul>
<p>Alternatively:</p>
<pre><code class="language-python">pipe(source &lt;&lt; range(5), out(into(set)))     # {0, 1, 2, 3, 4}
pipe(source &lt;&lt; range(5), out(into(sorted)))  # [0, 1, 2, 3, 4]
pipe(source &lt;&lt; range(5), out(into(min)))     #  0
pipe(source &lt;&lt; range(5), out(into(max)))     #              4
</code></pre>
<ul>
<li>
<p><code>out(into(...))</code> accepts a consumer of iterables.</p>
</li>
<li>
<p>Therefore, the default behaviour is equivalent to <code>out(into(list))</code>.</p>
</li>
</ul>
<h2><a class="header" href="#named-outputs" id="named-outputs">Named outputs</a></h2>
<pre><code class="language-python">pipe(source &lt;&lt; range(5), out.X           ).X  # [0, 1, 2, 3, 4]
pipe(source &lt;&lt; range(5), out.X     (add) ).X  # 10
pipe(source &lt;&lt; range(5), out.X(into(max))).X  # 4
</code></pre>
<ul>
<li>
<p><code>out</code>s can be associated with a name: <code>X</code> in these examples.</p>
</li>
<li>
<p>Naming <code>out</code>s causes the pipeline to return its results wrapped it a
namespace: note the <code>.X</code> after the pipeline.</p>
</li>
<li>
<p>This isn't very useful unless there are multiple <code>out</code>s in a single network,
and that won't make sense until we discover independent branches.</p>
</li>
</ul>
<h2><a class="header" href="#independent-branches" id="independent-branches">Independent branches</a></h2>
<pre><code class="language-python">result = pipe(source &lt;&lt; range(10), [ out.smallest(into(min)) ], out.biggest(into(max)))
assert result.biggest  == 9
assert result.smallest == 0
</code></pre>
<ul>
<li>
<p>Square brackets (<code>[  ]</code>) create <em>independent branches</em>.</p>
</li>
<li>
<p>Independent branches are pipes which receive all items reaching their position
in the pipeline, without affecting what is seen downstream.</p>
</li>
<li>
<p>Independent branches, just like other pipes, can end in <code>sink</code>s or <code>out</code>s. By
default, just like other pipes, they end in <code>out(into(list))</code>.</p>
</li>
<li>
<p>Anonymous <code>out</code>s, are bound to the name <code>return</code> in the returned namespace. As
<code>return</code> is a keyword, you will need to use <code>getattr</code> to access it. [This is
likely to change in future versions.]</p>
</li>
<li>
<p>If multiple <code>out</code>s in the same network have the same name, that name will be
bound to a tuple of all the results with that name. [This is likely to change
in future versions].</p>
</li>
<li>
<p>This network returned two results, grouped together in namespace, and bound to
the names <code>biggest</code> and <code>smallest</code></p>
</li>
</ul>
<h2><a class="header" href="#multiple-directories-and-progress-reporting" id="multiple-directories-and-progress-reporting">Multiple directories, and progress reporting</a></h2>
<p>Let's return to the code we're developing, and make a few more changes:</p>
<pre><code class="language-python">import os
from keyword import iskeyword
from liquidata import pipe, name, get, put, take, join, use, sink

fn = pipe(
    [ sink(lambda d: print(f'Processing input directory {d}')) ],
    os.walk,
    join,
    name.path.dirs.files,
    [ get.path, sink(lambda d: print(f'Processing discovered directory {d}')) ],
    get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename,
    get.path.filename * os.path.join,
    [ sink(lambda f: print(f'Processing file {f}')) ],
    open,
    join,
    use(str.split, '#', maxsplit=1),
    get[0],
    str.split,
    join,
    { iskeyword },
    take(30, close_all=True),
    sink(print))

fn(['/bin', '/usr/bin])
</code></pre>
<p>Firstly, observe that</p>
<ul>
<li>
<p><code>os.walk, join</code> has been spliced into the pipe (in positions 2 and 3).</p>
</li>
<li>
<p><code>fn</code> now receives a list of directories, rather than <code>os.walk(&lt;single-directory&gt;)</code>.</p>
</li>
<li>
<p>Each directory in the input list will be traversed by <code>os.walk</code>, and the
results will be <code>join</code>ed together into a single stream.</p>
</li>
</ul>
<p>Secondly, there are three othernew components:</p>
<ul>
<li><code>[           sink(lambda d: print(f'Processing directory {d}')) ]</code></li>
<li><code>[ get.path, sink(lambda d: print(f'Processing discovered directory {d}')) ]</code></li>
<li><code>[           sink(lambda f: print(f'Processing file {f}')) ]</code></li>
</ul>
<p>These are all independent branches, which report on what flows through the
network at different points.</p>
<p>Consequently, as python keywords are printed, we will be informed whenever</p>
<ul>
<li>
<p>we start processing the next directory in the input list</p>
</li>
<li>
<p><code>os.walk</code> enters a new directory</p>
</li>
<li>
<p>we start processing a new <code>.py</code> file</p>
</li>
</ul>
<h2><a class="header" href="#spy" id="spy"><code>spy</code></a></h2>
<p>Spy hasn't been implemented yet in the current version of <code>liquidata</code>, but the
following shortcuts should appear soon:</p>
<pre><code class="language-python">[ sink(&lt;side-effect&gt;) ]
   spy(&lt;side-effect&gt;)
</code></pre>
<pre><code class="language-python">[ out.X(&lt;binary-function&gt;) ]
  spy.X(&lt;binary-function&gt;)
</code></pre>
<pre><code class="language-python">[ out.X(into(&lt;iterator-consumer&gt;)) ]
  spy.X(into(&lt;iterator-consumer&gt;))
</code></pre>
<h2><a class="header" href="#frequency-analysis" id="frequency-analysis">Frequency analysis</a></h2>
<p>We're almost there. Let's calculate how many times each keyword appears:</p>
<pre><code class="language-python">import os
from keyword     import iskeyword
from collections import Counter
from liquidata   import pipe, name, get, put, take, join, use

fn = pipe(
    os.walk,
    join,
    name.path.dirs.files,
    get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename,
    get.path.filename * os.path.join,
    open,
    join,
    use(str.split, '#', maxsplit=1),
    get[0],
    str.split,
    join,
    { iskeyword },
    out(into(Counter)))
</code></pre>
<ul>
<li>
<p>We removed</p>
<ul>
<li>The branches which printed the progress report</li>
<li>The <code>take</code> which limited the data that flooded our screen</li>
</ul>
</li>
<li>
<p>We replaced the final <code>sink(print)</code> with <code>out(into(Counter))</code></p>
</li>
<li>
<p><code>collections.Counter</code> (from Python's standard library) consumes an iterable
(so it can be used with <code>into</code>) and associates each value with the number of
times it was seen.</p>
</li>
</ul>
<h2><a class="header" href="#abstraction" id="abstraction">Abstraction</a></h2>
<p>As it stands, the code throws all the details into our face. Let's cut it up
into smaller portions and give them suggestive names, to give a higher-level
overview of what the code is doing:</p>
<pre><code class="language-python">import os
from keyword     import iskeyword
from collections import Counter
from liquidata   import pipe, name, get, put, join, use

all_files         = os.walk, join, name.path.dirs.files,
find_python_files = get.files * (join, { use(str.endswith, '.py') }) &gt;&gt; put.filename
file_contents     = get.path.filename * os.path.join, open, join
discard_comments  = use(str.split, '#', maxsplit=1), get[0]
find_keywords     = str.split, join, { iskeyword }

fn = pipe(
    all_files,
    find_python_files,
    file_contents,
    discard_comments,
    find_keywords,
    out(into(Counter)))
</code></pre>
<p>And we're done!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="whirlwind.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="Architecture.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="whirlwind.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="Architecture.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
